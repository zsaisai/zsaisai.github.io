<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://gitee.com/z_saisai/ware_01/raw/master/blog_account/logo2.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://gitee.com/z_saisai/ware_01/raw/master/blog_account/logo2.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zsaisai.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>
<meta name="description" content="排序算法总结算法分类十种常见排序算法可以分为两大类：  比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。">
<meta property="og:type" content="article">
<meta property="og:title" content="十种排序算法">
<meta property="og:url" content="https://zsaisai.github.io/sort_summary/index.html">
<meta property="og:site_name" content="ZhangSaiSai">
<meta property="og:description" content="排序算法总结算法分类十种常见排序算法可以分为两大类：  比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://gitee.com/z_saisai/ware_01/raw/master/md_image/11.png">
<meta property="og:image" content="https://gitee.com/z_saisai/ware_01/raw/master/md_image/12.png">
<meta property="og:image" content="https://zsaisai.github.io/sort_summary/..%5Cimages%5C2.gif">
<meta property="og:image" content="https://zsaisai.github.io/sort_summary/..%5Cimages%5C1.gif">
<meta property="og:image" content="https://zsaisai.github.io/images/3.gif">
<meta property="og:image" content="https://zsaisai.github.io/images/4.gif">
<meta property="og:image" content="https://zsaisai.github.io/images/5.gif">
<meta property="og:image" content="https://zsaisai.github.io/images/6.gif">
<meta property="og:image" content="https://zsaisai.github.io/images/8.gif">
<meta property="og:image" content="https://zsaisai.github.io/images/9.png">
<meta property="og:image" content="https://zsaisai.github.io/images/10.gif">
<meta property="article:published_time" content="2020-05-17T14:46:35.000Z">
<meta property="article:modified_time" content="2021-08-09T08:39:25.792Z">
<meta property="article:author" content="ZHANGSAISAI">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/z_saisai/ware_01/raw/master/md_image/11.png">


<link rel="canonical" href="https://zsaisai.github.io/sort_summary/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://zsaisai.github.io/sort_summary/","path":"sort_summary/","title":"十种排序算法"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>十种排序算法 | ZhangSaiSai</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-129037882-1"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-129037882-1","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?d0967e9b160f4f6248804003642ee818"></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">ZhangSaiSai</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">二十多岁 人生才刚刚开始</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
        <li class="menu-item menu-item-schedule"><a href="/archives/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93"><span class="nav-number">1.</span> <span class="nav-text">排序算法总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB"><span class="nav-number">1.0.1.</span> <span class="nav-text">算法分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">1.0.2.</span> <span class="nav-text">算法复杂度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88Bubble-Sort%EF%BC%89"><span class="nav-number">1.1.</span> <span class="nav-text">冒泡排序（Bubble Sort）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%88Selection-Sort%EF%BC%89"><span class="nav-number">1.2.</span> <span class="nav-text">选择排序（Selection Sort）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88Insertion-Sort%EF%BC%89"><span class="nav-number">1.3.</span> <span class="nav-text">插入排序（Insertion Sort）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88Shell-Sort%EF%BC%89"><span class="nav-number">1.4.</span> <span class="nav-text">希尔排序（Shell Sort）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88Merge-Sort%EF%BC%89"><span class="nav-number">1.5.</span> <span class="nav-text">归并排序（Merge Sort）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88Quick-Sort%EF%BC%89"><span class="nav-number">1.6.</span> <span class="nav-text">快速排序（Quick Sort）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88Heap-Sort%EF%BC%89"><span class="nav-number">1.7.</span> <span class="nav-text">堆排序（Heap Sort）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88Counting-Sort%EF%BC%89"><span class="nav-number">1.8.</span> <span class="nav-text">计数排序（Counting Sort）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%B6%E6%8E%92%E5%BA%8F%EF%BC%88Bucket-Sort%EF%BC%89"><span class="nav-number">1.9.</span> <span class="nav-text">桶排序（Bucket Sort）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88Radix-Sort%EF%BC%89"><span class="nav-number">1.10.</span> <span class="nav-text">基数排序（Radix Sort）</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZHANGSAISAI"
      src="https://gitee.com/z_saisai/ware_01/raw/master/blog_account/profile.png">
  <p class="site-author-name" itemprop="name">ZHANGSAISAI</p>
  <div class="site-description" itemprop="description">Keep awake,Stay thinking</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zsaisai" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zsaisai" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:z_ss101@163.com" title="E-Mail → mailto:z_ss101@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/weixin_41744192?spm=1000.2115.3001.5343" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_41744192?spm&#x3D;1000.2115.3001.5343" rel="noopener" target="_blank"><i class="csdn fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/3564388084" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;3564388084" rel="noopener" target="_blank"><i class="weibo fa-fw"></i>Weibo</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://music.163.com/#/user/home?id=330376567" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;330376567" rel="noopener" target="_blank">Cloudmusic</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.rainymood.com/" title="https:&#x2F;&#x2F;www.rainymood.com&#x2F;" rel="noopener" target="_blank">Rainy Mood</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://paperswithcode.com/task/recommendation-systems" title="https:&#x2F;&#x2F;paperswithcode.com&#x2F;task&#x2F;recommendation-systems" rel="noopener" target="_blank">Papers with Code</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://datawhalechina.github.io/pumpkin-book/#/" title="https:&#x2F;&#x2F;datawhalechina.github.io&#x2F;pumpkin-book&#x2F;#&#x2F;" rel="noopener" target="_blank">Pumpkin-book</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://tangshusen.me/Dive-into-DL-PyTorch/#/" title="https:&#x2F;&#x2F;tangshusen.me&#x2F;Dive-into-DL-PyTorch&#x2F;#&#x2F;" rel="noopener" target="_blank">DL-Torch</a>
        </li>
    </ul>
  </div>

          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/zsaisai" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://zsaisai.github.io/sort_summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://gitee.com/z_saisai/ware_01/raw/master/blog_account/profile.png">
      <meta itemprop="name" content="ZHANGSAISAI">
      <meta itemprop="description" content="Keep awake,Stay thinking">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZhangSaiSai">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          十种排序算法
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-05-17 14:46:35" itemprop="dateCreated datePublished" datetime="2020-05-17T14:46:35+00:00">2020-05-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="排序算法总结"><a href="#排序算法总结" class="headerlink" title="排序算法总结"></a>排序算法总结</h1><h3 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h3><p>十种常见排序算法可以分为两大类：</p>
<ul>
<li><strong>比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</li>
<li><strong>非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</li>
</ul>
<span id="more"></span>

<p><img src="https://gitee.com/z_saisai/ware_01/raw/master/md_image/11.png" alt="1628302944177"> )</p>
<h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><p><img src="https://gitee.com/z_saisai/ware_01/raw/master/md_image/12.png" alt="1628303039720"></p>
<p><strong>相关概念</strong></p>
<ul>
<li><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li>
<li><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li>
<li><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li>
<li><strong>空间复杂度：</strong>是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</li>
</ul>
<h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><p> 冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。<strong>这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端</strong>。 </p>
<p><img src="..%5Cimages%5C2.gif"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span>(<span class="params">self,nums</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    1.比较相邻的元素。如果第一个比第二个大，就交换它们两个；</span></span><br><span class="line"><span class="string">    2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</span></span><br><span class="line"><span class="string">    3.针对所有的元素重复以上的步骤，除了最后一个；</span></span><br><span class="line"><span class="string">    4.重复步骤1~3，直到排序完成。</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>-i):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>]:</span><br><span class="line">                nums[j], nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>], nums[j]</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>

<h2 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h2><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p>
<p><img src="..%5Cimages%5C1.gif"></p>
<p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectionSort</span>(<span class="params">self,nums</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</span></span><br><span class="line"><span class="string">    初始状态：无序区为R[1..n]，有序区为空；</span></span><br><span class="line"><span class="string">    第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。</span></span><br><span class="line"><span class="string">    该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，</span></span><br><span class="line"><span class="string">    使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</span></span><br><span class="line"><span class="string">    n-1趟结束，数组有序化了。</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        min_num = nums[i]</span><br><span class="line">        min_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[j]&lt;min_num:</span><br><span class="line">                min_num = nums[j]</span><br><span class="line">                min_index = j</span><br><span class="line">        nums[i], nums[min_index] = nums[min_index], nums[i]</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>

<h2 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h2><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p><img src="../images/3.gif"></p>
<p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertionsort</span>(<span class="params">self,nums</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    从第一个元素开始，该元素可以认为已经被排序；</span></span><br><span class="line"><span class="string">    取出下一个元素，在已经排序的元素序列中从后向前扫描；</span></span><br><span class="line"><span class="string">    如果该元素（已排序）大于新元素，将该元素移到下一位置；</span></span><br><span class="line"><span class="string">    重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</span></span><br><span class="line"><span class="string">    将新元素插入到该位置后；</span></span><br><span class="line"><span class="string">    重复步骤2~5。</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">        temp = nums[i]</span><br><span class="line">        <span class="keyword">while</span>(i -<span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> temp&lt;nums[i-<span class="number">1</span>]):</span><br><span class="line">            nums[i] = nums[i-<span class="number">1</span>]</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        nums[i] = temp</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>

<h2 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h2><p>1959年Shell发明，第一个突破O(n2)的排序算法，<strong>是简单插入排序的改进版</strong>。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p>
<p><img src="../images/4.gif"></p>
<p> 希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。　 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shellSort</span>(<span class="params">self,nums</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</span></span><br><span class="line"><span class="string">    选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</span></span><br><span class="line"><span class="string">    按增量序列个数k，对序列进行k 趟排序；</span></span><br><span class="line"><span class="string">    每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。</span></span><br><span class="line"><span class="string">    仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    gap = <span class="built_in">int</span>(<span class="built_in">len</span>(nums)/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">while</span>(gap&gt;<span class="number">0</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap,<span class="built_in">len</span>(nums)):</span><br><span class="line">            j = i</span><br><span class="line">            current = nums[i]</span><br><span class="line">            <span class="keyword">while</span>(j - gap &gt;= <span class="number">0</span> <span class="keyword">and</span> current &lt; nums[j - gap]):</span><br><span class="line">                nums[j] = nums[j -gap]</span><br><span class="line">                j -= gap</span><br><span class="line">            nums[j] = current</span><br><span class="line">        gap = <span class="built_in">int</span>(gap/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>

<h2 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h2><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p>
<p><img src="../images/5.gif"></p>
<p>归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span>(<span class="params">self,nums</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    把长度为n的输入序列分成两个长度为n/2的子序列；</span></span><br><span class="line"><span class="string">    对这两个子序列分别采用归并排序；</span></span><br><span class="line"><span class="string">    将两个排序好的子序列合并成一个最终的排序序列。</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">len</span>(nums)==<span class="number">1</span>):<span class="keyword">return</span> nums</span><br><span class="line">    mid = <span class="built_in">int</span>(<span class="built_in">len</span>(nums)/<span class="number">2</span>)</span><br><span class="line">    left = nums[:mid]</span><br><span class="line">    right = nums[mid:]</span><br><span class="line">    <span class="keyword">return</span> self.merge(self.mergeSort(left),self.mergeSort(right))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self,left,right</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">len</span>(left)&gt;<span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(right)&gt;<span class="number">0</span>):</span><br><span class="line">        <span class="keyword">if</span> left[<span class="number">0</span>] &lt; right[<span class="number">0</span>]:</span><br><span class="line">            res.append(left.pop(<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.append(right.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">len</span>(left)&gt;<span class="number">0</span>):</span><br><span class="line">        res.append(left.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">len</span>(right)&gt;<span class="number">0</span>):</span><br><span class="line">        res.append(right.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h2><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<p><img src="../images/6.gif"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span>(<span class="params">self,nums</span>):</span></span><br><span class="line">    start, end = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quick</span>(<span class="params">nums,start,end</span>):</span></span><br><span class="line">        <span class="keyword">if</span> start &gt;= end:</span><br><span class="line">            <span class="keyword">return</span><span class="comment"># 递归的退出条件</span></span><br><span class="line">        mid = nums[start]<span class="comment"># 设定起始的基准元素</span></span><br><span class="line">        low = start<span class="comment"># low为序列左边在开始位置的由左向右移动的游标</span></span><br><span class="line">        high = end<span class="comment"># high为序列右边末尾位置的由右向左移动的游标</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            <span class="comment"># 如果low与high未重合，high(右边)指向的元素大于等于基准元素，则high向左移动</span></span><br><span class="line">            <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[high] &gt;= mid:</span><br><span class="line">                high -= <span class="number">1</span></span><br><span class="line">            nums[low] = nums[high]</span><br><span class="line">            <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[low] &lt;= mid:</span><br><span class="line">                low += <span class="number">1</span></span><br><span class="line">            nums[high] = nums[low]</span><br><span class="line">        nums[low] = mid</span><br><span class="line">        quick(nums,start,low-<span class="number">1</span>)</span><br><span class="line">        quick(nums,low+<span class="number">1</span>,end)</span><br><span class="line">    quick(nums,start,end)</span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>

<h2 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h2><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<p><strong>a.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</strong></p>
<p><strong>b.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</strong></p>
<p><strong>c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">big_endian</span>(<span class="params">self, arr, start, end</span>):</span></span><br><span class="line">        root = start<span class="comment">#取出当前元素作为根</span></span><br><span class="line">        child = root * <span class="number">2</span> + <span class="number">1</span>  <span class="comment"># 求出其对应的左孩子</span></span><br><span class="line">        <span class="keyword">while</span> child &lt;= end:</span><br><span class="line">            <span class="comment"># 孩子比最后一个节点还大，也就意味着最后一个叶子节点了，就得跳出去一次循环，已经调整完毕</span></span><br><span class="line">            <span class="keyword">if</span> child + <span class="number">1</span> &lt;= end <span class="keyword">and</span> arr[child] &lt; arr[child + <span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 为了始终让其跟子元素的较大值比较，如果右边存在且比左边大就左换右，左边大的话就默认</span></span><br><span class="line">                child += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> arr[root] &lt; arr[child]:</span><br><span class="line">                <span class="comment"># 父节点小于子节点直接交换位置，同时坐标也得换，这样下次循环while可以准确判断：是否为最底层，</span></span><br><span class="line">                <span class="comment"># 是不是调整完毕</span></span><br><span class="line">                arr[root], arr[child] = arr[child], arr[root]</span><br><span class="line">                root = child</span><br><span class="line">                child = root * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#当前元素比左右都大 无需调整 直接跳出</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span>(<span class="params">self,arr</span>):</span>  <span class="comment"># 大根堆排序</span></span><br><span class="line">        <span class="comment"># 计算最后一个非叶子节点</span></span><br><span class="line">        first = <span class="built_in">len</span>(arr) // <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 1.开始构建大顶堆</span></span><br><span class="line">        <span class="keyword">for</span> start <span class="keyword">in</span> <span class="built_in">range</span>(first, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 从第一个非叶子结点从下至上，从右至左调整结构</span></span><br><span class="line">            self.big_endian(arr, start, <span class="built_in">len</span>(arr) - <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 2.调整堆结构+交换堆顶元素与末尾元素</span></span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            arr[<span class="number">0</span>], arr[end] = arr[end], arr[<span class="number">0</span>]  <span class="comment"># 顶部尾部互换位置</span></span><br><span class="line">            self.big_endian(arr, <span class="number">0</span>, end - <span class="number">1</span>)  <span class="comment"># 重新调整子节点的顺序，从顶开始调整</span></span><br><span class="line">        <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>

<h2 id="计数排序（Counting-Sort）"><a href="#计数排序（Counting-Sort）" class="headerlink" title="计数排序（Counting Sort）"></a>计数排序（Counting Sort）</h2><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p>计数排序是一个稳定的排序算法。<strong>当输入的元素是 n 个 0到 k 之间的整数时</strong>，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，<strong>其排序速度快于任何比较排序算法</strong>。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。 </p>
<ul>
<li>创建一个bucket,容量为数组最大数+1个(0-max)</li>
<li>统计数组中每个值为出现的次数，存入bucket</li>
<li>反向填充数组,从0开始到max,按出现的次数依次存储到数组中</li>
</ul>
<p><img src="../images/8.gif"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countingSort</span>(<span class="params">self,nums</span>):</span></span><br><span class="line">    bucket = [<span class="number">0</span>]*(<span class="built_in">max</span>(nums)+<span class="number">1</span>)</span><br><span class="line">    c = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        bucket[nums[i]] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(bucket)):</span><br><span class="line">        <span class="keyword">while</span>(bucket[j]&gt;<span class="number">0</span>):</span><br><span class="line">            nums[c] = j</span><br><span class="line">            c += <span class="number">1</span></span><br><span class="line">            bucket[j] -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>

<h2 id="桶排序（Bucket-Sort）"><a href="#桶排序（Bucket-Sort）" class="headerlink" title="桶排序（Bucket Sort）"></a>桶排序（Bucket Sort）</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p>
<p><img src="../images/9.png"></p>
<ul>
<li>设置一个定量的数组当作空桶；</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>对每个不是空的桶进行排序；</li>
<li>从不是空的桶里把排好序的数据拼接起来。 </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 桶排序可以看成是计数排序的升级版,计数排序的一个单位是一个数,而桶排序的一个单位是一个区间</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucketSort</span>(<span class="params">self,numList, bucketNum</span>):</span></span><br><span class="line">    <span class="keyword">import</span> math</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(numList) &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> numList</span><br><span class="line"></span><br><span class="line">    maxNum = <span class="built_in">max</span>(numList)</span><br><span class="line">    minNum = <span class="built_in">min</span>(numList)</span><br><span class="line"></span><br><span class="line">    bucketLength = <span class="built_in">len</span>(numList) - <span class="number">1</span></span><br><span class="line">    bucketSize = ((maxNum - minNum) / bucketLength)  <span class="comment"># 根据桶的数量找到每个桶的取值范围</span></span><br><span class="line">    buckets = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(bucketLength)]</span><br><span class="line">    <span class="built_in">print</span>(buckets)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(numList)):  <span class="comment"># 将各个数分配到各个桶</span></span><br><span class="line">        <span class="comment"># num_bucktes_local界定范围.只要大于第n个桶,就是在第n+1个桶里.所以是向上取整.</span></span><br><span class="line">        <span class="comment"># 比如说 numList = [1,40,50,60,200].</span></span><br><span class="line">        num_bucktes_local = math.ceil((numList[i] - minNum) / bucketSize) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> num_bucktes_local &lt;= <span class="number">0</span>:  <span class="comment"># 最小值是 == -1 的.</span></span><br><span class="line">            num_bucktes_local = <span class="number">0</span></span><br><span class="line">        buckets[num_bucktes_local].append(numList[i])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ---可删除---</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;桶的取值范围是:&#x27;</span>, bucketSize)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;每个桶:&#x27;</span>, buckets)</span><br><span class="line">    <span class="comment"># ---可删除---</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(bucketLength):  <span class="comment"># 桶内排序，可以使用各种排序方法</span></span><br><span class="line">        buckets[i].sort()</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(buckets)):  <span class="comment"># 分别将各个桶内的数提出来，压入结果</span></span><br><span class="line">        res.extend(buckets[i])</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h2 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h2><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>
<p><img src="../images/10.gif"></p>
<p>基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radixSort</span>(<span class="params">self,nums</span>):</span></span><br><span class="line">    pos_list = []</span><br><span class="line">    neg_list = []</span><br><span class="line">    <span class="comment"># 将待排序列分为正负两组</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> num &lt; <span class="number">0</span>:</span><br><span class="line">            neg_list.append(num)</span><br><span class="line">        <span class="keyword">if</span> num &gt;= <span class="number">0</span>:</span><br><span class="line">            pos_list.append(num)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_radixSort</span>(<span class="params">num_list</span>):</span></span><br><span class="line">        num_digit = <span class="number">0</span> <span class="comment"># 分桶的位数，0代表个位，1为十位...</span></span><br><span class="line">        e = <span class="built_in">min</span>(num_list)<span class="keyword">if</span> num_list[<span class="number">0</span>] &lt; <span class="number">0</span> <span class="keyword">else</span> <span class="built_in">max</span>(num_list)<span class="comment"># 得到最小/大的数</span></span><br><span class="line">        <span class="keyword">while</span> num_digit &lt; <span class="built_in">len</span>(<span class="built_in">str</span>(e)):<span class="comment"># 分桶位数(从0开始)小于最小/大数的位数</span></span><br><span class="line">            num_values = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]<span class="comment"># 初始化桶</span></span><br><span class="line">            <span class="comment"># 把待排数按位数分桶</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> num_list:</span><br><span class="line">                num_values[<span class="built_in">int</span>(num / (<span class="number">10</span> ** num_digit)) % <span class="number">10</span>].append(num)</span><br><span class="line">            num_list.clear()</span><br><span class="line">            <span class="comment"># 从桶中取出已排的数</span></span><br><span class="line">            <span class="keyword">for</span> num_value <span class="keyword">in</span> num_values:</span><br><span class="line">                <span class="keyword">for</span> num <span class="keyword">in</span> num_value:</span><br><span class="line">                    num_list.append(num)</span><br><span class="line">            <span class="comment">#更新位数，进行下一次分桶</span></span><br><span class="line">            num_digit += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> num_list</span><br><span class="line">    <span class="comment"># 按正负，分别排序</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(neg_list) != <span class="number">0</span>:neg_list = _radixSort(neg_list)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pos_list) != <span class="number">0</span>:pos_list = _radixSort(pos_list)</span><br><span class="line">    <span class="comment"># 组合返回</span></span><br><span class="line">    <span class="keyword">return</span> neg_list + pos_list</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"><i class="fa fa-tag"></i> 数据结构</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E5%93%8D%E5%BA%94%E7%9A%84%E8%BF%87%E7%A8%8B/" rel="prev" title="浏览器输入网址到响应的过程">
                  <i class="fa fa-chevron-left"></i> 浏览器输入网址到响应的过程
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/optimization/" rel="next" title="optimization总结">
                  optimization总结 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC80MjE1MS8xODY5OA=="></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="snowflake-o"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZHANGSAISAI</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  




  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script src="/js/third-party/comments/livere.js"></script>

</body>
</html>
